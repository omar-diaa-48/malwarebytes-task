import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import api from "../../utils/api";
import { ActionPayloadType, AxiosResponseDataType } from "../../utils/types";
import { GroupedProducts, IProductActionResponse } from "../../interfaces/responses/product";

export interface ProductsState {
	items: GroupedProducts;
}

const initialState = {
	items: {}
} as ProductsState;

export const getAllProductsAsyncAction = createAsyncThunk<GroupedProducts, void>('products/getAllProducts', async (val, { rejectWithValue }) => {
	try {
		const res = await api.get('/products');

		const data: AxiosResponseDataType<GroupedProducts> = res.data;

		return data.data;
	} catch (err) {
		return rejectWithValue(err)
	}
})

export const incrementProductAsyncAction = createAsyncThunk<IProductActionResponse, { productId: string }>('products/incrementProduct', async ({ productId }, { rejectWithValue }) => {
	try {
		const res = await api.post(`/products/${productId}`);

		const data: AxiosResponseDataType<IProductActionResponse> = res.data;

		return data.data;
	} catch (err) {
		return rejectWithValue(err)
	}
})

export const decrementProductAsyncAction = createAsyncThunk<IProductActionResponse, { productId: string }>('products/decrementProduct', async ({ productId }, { rejectWithValue }) => {
	try {
		const res = await api.delete(`/products/${productId}`);

		const data: AxiosResponseDataType<IProductActionResponse> = res.data;

		return data.data;
	} catch (err) {
		return rejectWithValue(err)
	}
})

export const productsSlice = createSlice({
	name: 'products',
	initialState,
	reducers: {},
	extraReducers: {
		[getAllProductsAsyncAction.fulfilled.type]: (state, action: ActionPayloadType<GroupedProducts>) => {
			const items = action.payload;

			return {
				...state,
				items
			};
		},

		[incrementProductAsyncAction.fulfilled.type]: (state, action: ActionPayloadType<IProductActionResponse>) => {
			const { valid, productId, categoryTitle } = action.payload

			return {
				...state,
				items: {
					...state.items,
					[categoryTitle]: state.items[categoryTitle].map((product) => {
						if (product._id === productId) {
							return {
								...product,
								availableCount: product.availableCount + 1
							}
						}

						return product;
					})

				}
			}
		},

		[decrementProductAsyncAction.fulfilled.type]: (state, action: ActionPayloadType<IProductActionResponse>) => {
			const { valid, productId, categoryTitle } = action.payload

			return {
				...state,
				items: {
					...state.items,
					[categoryTitle]: state.items[categoryTitle].map((product) => {
						if (product._id === productId) {
							return {
								...product,
								availableCount: product.availableCount - 1
							}
						}

						return product;
					})
				}
			}
		}
	}
})

export default productsSlice.reducer