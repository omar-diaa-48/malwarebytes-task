import { Test } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { AuthService } from './auth.service';
import { UserService } from '../user/user.service';
import { AuthDto } from './auth.dto';
import { JwtPayload } from './dto/jwt-payload';
import { NotFoundException, BadRequestException, UnauthorizedException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
import { User } from 'src/models/user';

describe('AuthService', () => {
	let authService: AuthService;
	let userService: UserService;
	let configService: ConfigService;

	const mockUser = {
		id: '1',
		username: 'testuser',
		password: bcrypt.hashSync('testpassword', 10),
	};

	const mockAuthDto: AuthDto = {
		username: 'testuser',
		password: 'testpassword',
	};

	beforeEach(async () => {
		const moduleRef = await Test.createTestingModule({
			providers: [
				AuthService,
				{
					provide: UserService,
					useValue: {
						findUserByUserName: jest.fn().mockResolvedValue(mockUser),
						createUser: jest.fn().mockResolvedValue(mockUser),
					},
				},
				{
					provide: ConfigService,
					useValue: {
						get: jest.fn().mockReturnValue('testsecret'),
					},
				},
			],
		}).compile();

		authService = moduleRef.get<AuthService>(AuthService);
		userService = moduleRef.get<UserService>(UserService);
		configService = moduleRef.get<ConfigService>(ConfigService);
	});

	describe('login', () => {
		it('should throw NotFoundException if user is not found', async () => {
			jest.spyOn(userService, 'findUserByUserName').mockResolvedValueOnce(undefined);

			await expect(authService.login(mockAuthDto)).rejects.toThrowError(NotFoundException);
		});

		it('should throw NotFoundException if password is incorrect', async () => {
			jest.spyOn(bcrypt, 'compareSync').mockReturnValueOnce(false);

			await expect(authService.login(mockAuthDto)).rejects.toThrowError(NotFoundException);
		});

		it('should return a JwtPayload if authentication is successful', async () => {
			const result = await authService.login(mockAuthDto);

			expect(result).toHaveProperty('id');
			expect(result).toHaveProperty('username');
			expect(result).toHaveProperty('jwt_token');
		});
	});

	describe('register', () => {
		it('should create a new user and return a JwtPayload if registration is successful', async () => {
			jest.spyOn(userService, 'findUserByUserName').mockResolvedValueOnce(null);

			const result = await authService.register(mockAuthDto);

			expect(userService.createUser).toHaveBeenCalledWith({
				username: mockAuthDto.username,
				password: mockAuthDto.password,
			});

			expect(result).toHaveProperty('id');
			expect(result).toHaveProperty('username');
			expect(result).toHaveProperty('jwt_token');
		});

		it('should throw BadRequestException if user already exists', async () => {
			jest.spyOn(userService, 'findUserByUserName').mockResolvedValueOnce(mockUser as User);

			await expect(authService.register(mockAuthDto)).rejects.toThrowError(BadRequestException);
		});
	});

	describe('jwtSignIn', () => {
		it('should throw UnauthorizedException if user is not provided', async () => {
			await expect(authService.jwtSignIn(undefined)).rejects.toThrowError(UnauthorizedException);
		});

		it('should throw UnauthorizedException if user cannot be found', async () => {
			jest.spyOn(userService, 'findUserByUserName').mockResolvedValueOnce(undefined);

			await expect(authService.jwtSignIn(mockUser)).rejects.toThrowError(UnauthorizedException);
		});

		it('should return a JwtPayload if authentication is successful', async () => {
			const result = await authService.jwtSignIn(mockUser);

			expect(result).toHaveProperty('id');
			expect(result).toHaveProperty('username');
			expect(result).toHaveProperty('jwt_token');
		});
	});
});