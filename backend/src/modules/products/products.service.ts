import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from "mongoose";
import { ProductItem } from 'src/models/product-item';
import { ProductCategory } from 'src/models/product-category';
import { ERROR_MESSAGES } from 'src/utils/message';
import { SocketService } from '../socket/socket.service';

@Injectable()
export class ProductsService {
	constructor(
		@InjectModel('ProductItem') private productItemModel: Model<ProductItem>,
		@InjectModel('ProductCategory') private productCategoryModel: Model<ProductCategory>,
		private readonly socketService?: SocketService,
	) { }

	async findAllProucts(): Promise<{ [key: string]: ProductItem[] }> {
		const products = await this.productItemModel.find({}).populate("productCategory")

		const groupedProducts = {}

		products.forEach((product) => {
			if (groupedProducts[product.productCategory.title]) {
				groupedProducts[product.productCategory.title].push(product)
			}
			else {
				groupedProducts[product.productCategory.title] = [product]
			}
		})

		return groupedProducts;
	}

	async incrementProduct(productId: string): Promise<{ valid: boolean, productId: string, categoryTitle: string }> {
		const productItem = await this.productItemModel.findById(productId).populate('productCategory');

		if (!productItem) {
			throw new NotFoundException(ERROR_MESSAGES.PRODUCTS.NOT_FOUND)
		}

		productItem.availableCount = productItem.availableCount + 1;
		await productItem.save();

		// Emit product item change
		this.socketService.socket.emit('product-item-change', { productItem, action: 'increased' })

		return { valid: true, productId, categoryTitle: productItem.productCategory.title }
	}

	async decrementProduct(productId: string): Promise<{ valid: boolean, productId: string, categoryTitle: string }> {
		const productItem = await this.productItemModel.findById(productId).populate('productCategory');;

		if (!productItem) {
			throw new NotFoundException(ERROR_MESSAGES.PRODUCTS.NOT_FOUND)
		}

		if (productItem.availableCount < 1) {
			throw new NotFoundException(ERROR_MESSAGES.PRODUCTS.INVALID_COUNT)
		}

		productItem.availableCount = productItem.availableCount - 1;
		await productItem.save();

		// Emit product item change
		this.socketService.socket.emit('product-item-change', { productItem, action: 'decreased' })

		return { valid: true, productId, categoryTitle: productItem.productCategory.title }
	}

	async insertProductCategory(insertProductCategoryDto: Partial<ProductCategory>): Promise<ProductCategory> {
		return this.productCategoryModel.create(insertProductCategoryDto)
	}

	async insertManyProducts(insertManyProductsDto: Partial<ProductItem>[]): Promise<ProductItem[]> {
		return this.productItemModel.insertMany(insertManyProductsDto)
	}
}