import { Test, TestingModule } from '@nestjs/testing';
import { getModelToken } from '@nestjs/mongoose';
import { ProductsService } from './products.service';
import { SocketService } from '../socket/socket.service';
import { BadRequestException, NotFoundException } from '@nestjs/common';
import { ProductItem } from 'src/models/product-item';
import { ProductCategory } from 'src/models/product-category';
import { Model } from 'mongoose';
import { ERROR_MESSAGES } from 'src/utils/message';

describe('ProductsService', () => {
	let service: ProductsService;
	let productItemModelMock: Model<ProductItem>;
	let productCategoryModelMock: Model<ProductCategory>;
	let socketServiceMock: SocketService;

	beforeEach(async () => {
		productItemModelMock = {
			find: jest.fn(),
			findById: jest.fn(),
			insertMany: jest.fn(),
			create: jest.fn(),
			save: jest.fn()
		} as any;

		productCategoryModelMock = {
			create: jest.fn(),
		} as any;

		socketServiceMock = {
			socket: {
				emit: jest.fn(),
			},
		} as any;

		const module: TestingModule = await Test.createTestingModule({
			providers: [
				ProductsService,
				{
					provide: getModelToken('ProductItem'),
					useValue: productItemModelMock,
				},
				{
					provide: getModelToken('ProductCategory'),
					useValue: productCategoryModelMock,
				},
				{
					provide: SocketService,
					useValue: socketServiceMock,
				},
			],
		}).compile();

		service = module.get<ProductsService>(ProductsService);
	});

	afterEach(() => {
		jest.resetAllMocks();
	});

	describe('findAllProducts', () => {
		it('should return an object with products grouped by category', async () => {
			const productCategory = { _id: '1', title: 'Category 1' } as ProductCategory;
			const productItems = [
				{ _id: '1', title: 'Product 1', description: 'Product 1', availableCount: 2, productCategory } as ProductItem,
				{ _id: '2', title: 'Product 2', description: 'Product 2', availableCount: 1, productCategory } as ProductItem,
				{ _id: '3', title: 'Product 3', description: 'Product 3', availableCount: 3, productCategory } as ProductItem,
			];

			(productItemModelMock.find as jest.Mock).mockResolvedValueOnce(productItems);

			const result = await service.findAllProducts();

			expect(result).toEqual({
				'Category 1': productItems,
			});
		});
	});

	describe('incrementProduct', () => {
		it('should increment the available count of the given product and emit a socket event', async () => {
			const productId = '1';
			const productCategory = { _id: '1', title: 'Category 1' } as ProductCategory;
			const productItem = { _id: productId, title: 'Product 1', availableCount: 2, productCategory, save(options) { } } as ProductItem;
			(productItemModelMock.findById as jest.Mock).mockResolvedValueOnce(productItem);

			jest.spyOn(productItem, 'save')

			const result = await service.incrementProduct(productId);

			expect(result).toEqual({ valid: true, productItem, productId, categoryTitle: 'Category 1' });
			expect(productItem.availableCount).toBe(3);
			expect(productItem.save).toHaveBeenCalled();
		});

		it('should throw NotFoundException if the product item is not found', async () => {
			const productId = '1';
			(productItemModelMock.findById as jest.Mock).mockResolvedValueOnce(null);

			await expect(service.incrementProduct(productId)).rejects.toThrow(NotFoundException);
			await expect(service.incrementProduct(productId)).rejects.toThrow(ERROR_MESSAGES.PRODUCTS.NOT_FOUND);
		});
	});

	describe('decrementProduct', () => {
		it('should decrement the available count of the given product and emit a socket event', async () => {
			const productId = '1';
			const productCategory = { _id: '1', title: 'Category 1' } as ProductCategory;
			const productItem = { _id: productId, title: 'Product 1', availableCount: 2, productCategory, save(options) { } } as ProductItem;
			(productItemModelMock.findById as jest.Mock).mockResolvedValue(productItem);

			jest.spyOn(productItem, 'save')

			const result = await service.decrementProduct(productId);

			expect(result).toEqual({ valid: true, productItem, productId, categoryTitle: 'Category 1' });
			expect(productItem.availableCount).toBe(1);
			expect(productItem.save).toHaveBeenCalled();
		});

		it('should throw NotFoundException if the product item is not found', async () => {
			const productId = '1';
			(productItemModelMock.findById as jest.Mock).mockResolvedValueOnce(null);

			await expect(service.decrementProduct(productId)).rejects.toThrow(NotFoundException);
			await expect(service.decrementProduct(productId)).rejects.toThrow(ERROR_MESSAGES.PRODUCTS.NOT_FOUND);
		});

		it('should throw BadRequestException if the available count of the product is already zero', async () => {
			const productId = '1';
			const productCategory = { _id: '1', title: 'Category 1' } as ProductCategory;
			const productItem = { _id: productId, title: 'Product 1', availableCount: 0, productCategory } as ProductItem;
			(productItemModelMock.findById as jest.Mock).mockResolvedValue(productItem);

			await expect(service.decrementProduct(productId)).rejects.toThrow(BadRequestException);
			await expect(service.decrementProduct(productId)).rejects.toThrow(ERROR_MESSAGES.PRODUCTS.INVALID_COUNT);
		});
	});

	describe('insertProductCategory', () => {
		it('should create a new product category', async () => {
			const productCategoryDto = { title: 'Category 1' };
			const createdProductCategory = { _id: '1', ...productCategoryDto } as ProductCategory;
			(productCategoryModelMock.create as jest.Mock).mockResolvedValueOnce(createdProductCategory);

			const result = await service.insertProductCategory(productCategoryDto);

			expect(result).toEqual(createdProductCategory);
			expect(productCategoryModelMock.create).toHaveBeenCalledWith(productCategoryDto);
		});
	});
});